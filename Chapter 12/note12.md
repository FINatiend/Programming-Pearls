#第十二章 取样问题
##知识点
##笔记
1. 如何正确理解所遇到的问题以及提炼问题将问题抽象化
2. 写出尽可能多的解法（可用伪代码和抽象数据类型）
3. 实现一种可能比较优秀的解法
4. 选择认为最优的解法后回顾，考虑是否可以改进
###关于12.1及12.2的思考

首先重新回顾下问题：

> 程序的输入包含两个整数m和n，其中m<n。输出m个随机且
> 不重复的数，这些数的范围是0~n-1 且输出序列是有序的，每个
> 数出现的概率是一样的。

可以理解为：  
> 实现random.sample(range(0,100),20), range(0,100)是0-99，100个数  
> 就是把一个一个生成的随机数改造成在一定范围内可以一次性生成多个不重复
> 且有序的随机数列  

**重要的是每个数字选取的概率相等！**  

解决方法：  
* ~~关于有序~~
  1. ~~先输出m个数然后再排序~~
  2. ~~直接输出为有序~~
* ~~关于不重复序列~~  
  ~~直接选取一个数，然后将此数从样本空间中除去。因为每个数的概率改变了。~~
* ~~关于等概率~~  
* **方法一：采用辅助数据结构位图,先存储再排序，且每个数字选取的概率相等**
~~~Think1.py
from bitarray import bitarray
import random
#假设n为100，m为20
n = 100
m =20
a=bitarray(100)
a.setall(0)
b=[]
#辅助数据结构为位序列，代表0-99这100个数是否被选过
#a[0]=1，表示被选过，a[0]=0表示未被选过,初始都为0
while m>0:
    #如果提供的随机数没有确定的范围，则可以通过取余数操作进行限制
    i=random.randint(0,99)
    if a[i]==0:
        a[i]=1
        b.append(i)
        m=m-1
#使用排序算法将序列有序
b.sort()
print(b)
~~~
* **（最重要）方法二：书上直接输出有序随机不重复序列**
~~~Think2.py
import random
m=20
n=100
a=[]
#根据题意，输出序列数的大小范围是0-n
for i in range(0,100):
    #实际操作中模运算只需将随机数的范围控制到0-n，就可以覆盖模运算的所有结果
    if (random.randint(0,100)%n)< m :
        a.append(i)
        m=m-1
    n=n-1
print(a,'\n',len(a))
~~~
可以发现方法二是方法一的变种，只是将去除的部分改为去除选中数字之前的所有数字
以此来保证有序性（即每次选取的数字总比前一个大）.但方法二的优势还有其没有用
到其他数据结构，只用最简单的整数完成算法。此外方法二能够保证一定能输出m个数：  
先考虑这种情况
~~~
for i in range(0,100):
    #实际操作中模运算只需将随机数的范围控制到0-n，就可以覆盖模运算的所有结果
    if (random.randint(0,100)%n)< m :
        a.append(i)
        m=m-1
        n=n-1
~~~
这种情况下保证了选取一个数字之后，选取下一个数字的概率为(m-1)/(n-1)
但是会导致a的元素个数不一定是m个，举极端例子来说：当i的值为99时，if语句可能还没执行。  
仔细分析会发现上面这种错误的情况是由于错误得认为选取一个数之后，剩余数被选取的
概率一定为(m-1)/(n-1)。事实上只要每个数字选取的概率为相等概率就可以了。  
有兴趣的小伙伴可以看下方法一和方法二的性能测试。  
* **方法三：往初始为空的集合里面随机插入整数，直到个数足够**
~~~Think3.py
import random
#输入为m,n。输出为个数为m,数字大小在0~n-1的有序数列,set 保证不重复。
m=20
n=100
a=set()
i=20
while i >0 :
    t=random.randint(0,100)
    if ~(t in a):
        a.add(t)
        i=i-1
a=list(a)
a.sort()
~~~
这里遇到一个奇怪的现象：Python中的set集合本来是无序的，但在实际操作中set集合(不转化
为list有序化之后)直接输出也是有序的，这里要注意不能依赖这种特性,必须对其进行有序化。
* **方法四：将包含0~n-1的数组顺序的前m个元素顺序打乱2**
~~~Think4
#打乱有序数组前m位顺，输出前m位，然后再排序
import random
a=list(range(0,100))
i=0
while i<20 :
    t = random.randint(0,99)
    j=a[i]
    a[i]=a[t]
    a[t]=j
    i=i+1
a=a[0:20]
a.sort()
~~~
**总结\:**方法二最优，方法三优于方法一。
### 